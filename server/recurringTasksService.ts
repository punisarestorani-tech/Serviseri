import { storage } from "./storage";
import type { Task, InsertTask } from "@shared/schema";

export function calculateNextOccurrenceDate(
  baseDate: string,
  pattern: string,
  interval: number = 1
): string | null {
  if (pattern === "none") return null;
  
  const date = new Date(baseDate);
  
  switch (pattern) {
    case "weekly":
      date.setDate(date.getDate() + (7 * interval));
      break;
    case "monthly":
      date.setMonth(date.getMonth() + interval);
      break;
    case "quarterly":
      date.setMonth(date.getMonth() + (3 * interval));
      break;
    case "semi-annual":
      date.setMonth(date.getMonth() + (6 * interval));
      break;
    case "yearly":
      date.setFullYear(date.getFullYear() + interval);
      break;
    default:
      return null;
  }
  
  return date.toISOString().split('T')[0];
}

export async function generateRecurringTasks(): Promise<{
  generated: number;
  tasks: Task[];
}> {
  const tasksToRenew = await storage.getRecurringTasksDue();
  const newTasks: Task[] = [];
  
  for (const task of tasksToRenew) {
    if (!task.nextOccurrenceDate || !task.recurrencePattern || task.recurrencePattern === "none") continue;
    
    if (task.isAutoGenerated && task.parentTaskId) {
      continue;
    }
    
    const today = new Date().toISOString().split('T')[0];
    if (task.nextOccurrenceDate > today) continue;
    
    const nextDate = calculateNextOccurrenceDate(
      task.nextOccurrenceDate,
      task.recurrencePattern,
      task.recurrenceInterval || 1
    );
    
    const newTaskData: InsertTask = {
      clientId: task.clientId,
      applianceId: task.applianceId,
      userId: task.userId,
      description: task.description,
      status: "pending",
      priority: task.priority,
      dueDate: task.nextOccurrenceDate,
      taskType: "recurring",
      recurrencePattern: task.recurrencePattern,
      recurrenceInterval: task.recurrenceInterval,
      parentTaskId: task.parentTaskId || task.id,
      isAutoGenerated: true,
      nextOccurrenceDate: nextDate,
    };
    
    const newTask = await storage.createTask(newTaskData);
    newTasks.push(newTask);
    
    if (!task.parentTaskId) {
      await storage.updateTask(task.id, {
        nextOccurrenceDate: nextDate,
      });
    }
  }
  
  return {
    generated: newTasks.length,
    tasks: newTasks,
  };
}
