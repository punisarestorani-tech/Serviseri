import { sql } from "drizzle-orm";
import { pgTable, text, varchar, timestamp, integer, date, json } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

export const profiles = pgTable("profiles", {
  id: varchar("user_id").primaryKey(),
  username: varchar("username").notNull(),
  passwordHash: varchar("password_hash").notNull(),
  fullName: varchar("full_name").notNull(),
  email: varchar("email"),
  userRole: varchar("user_role").default("technician"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const clients = pgTable("clients", {
  id: varchar("id").primaryKey(),
  name: varchar("name").notNull(),
  address: varchar("address"),
  contact: varchar("contact"),
  pib: varchar("pib"),
  pdv: varchar("pdv"),
  account: varchar("account"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const appliances = pgTable("appliances", {
  id: varchar("id").primaryKey(),
  clientId: varchar("client_id").notNull().references(() => clients.id, { onDelete: "cascade" }),
  maker: varchar("maker"),
  type: varchar("type"),
  model: varchar("model"),
  serial: varchar("serial"),
  picture: varchar("picture"),
  city: varchar("city"),
  building: varchar("building"),
  room: varchar("room"),
  lastServiceDate: date("last_service_date"),
  nextServiceDate: date("next_service_date"),
  installDate: date("install_date"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const tasks = pgTable("tasks", {
  id: varchar("id").primaryKey(),
  clientId: varchar("client_id").notNull().references(() => clients.id, { onDelete: "cascade" }),
  applianceId: varchar("appliance_id").references(() => appliances.id, { onDelete: "set null" }),
  userId: varchar("user_id").references(() => profiles.id, { onDelete: "set null" }),
  status: text("status").notNull().default("pending"),
  taskType: text("task_type").notNull().default("one-time"),
  description: text("description").notNull(),
  dueDate: date("due_date"),
  priority: text("priority").default("normal"),
  
  recurrencePattern: text("recurrence_pattern").default("none"),
  recurrenceInterval: integer("recurrence_interval").default(1),
  parentTaskId: varchar("parent_task_id").references((): any => tasks.id, { onDelete: "set null" }),
  isAutoGenerated: integer("is_auto_generated").default(0),
  nextOccurrenceDate: date("next_occurrence_date"),
  
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
  completedAt: timestamp("completed_at", { withTimezone: true }),
  reportId: varchar("report_id"),
});

export const reports = pgTable("reports", {
  id: varchar("id").primaryKey(),
  taskId: varchar("task_id").notNull().references(() => tasks.id, { onDelete: "cascade" }),
  description: text("description").notNull(),
  sparePartsUsed: text("spare_parts_used"),
  workDuration: integer("work_duration"),
  photos: text("photos").array(),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const documents = pgTable("documents", {
  id: varchar("id").primaryKey(),
  name: varchar("name").notNull(),
  type: varchar("type"),
  url: varchar("url").notNull(),
  relatedTo: varchar("related_to"),
  relatedId: varchar("related_id"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const spareParts = pgTable("spare_parts", {
  id: varchar("id").primaryKey(),
  name: varchar("name").notNull(),
  partNumber: varchar("part_number"),
  manufacturer: varchar("manufacturer"),
  quantityInStock: integer("quantity_in_stock").default(0),
  minimumStockLevel: integer("minimum_stock_level").default(0),
  unitPrice: integer("unit_price"),
  location: varchar("location"),
  createdAt: timestamp("created_at", { withTimezone: true }).defaultNow(),
});

export const insertProfileSchema = createInsertSchema(profiles).omit({ id: true, createdAt: true });
export const insertClientSchema = createInsertSchema(clients).omit({ id: true, createdAt: true });
export const insertApplianceSchema = createInsertSchema(appliances).omit({ id: true, createdAt: true });
export const insertTaskSchema = createInsertSchema(tasks).omit({ 
  id: true, 
  createdAt: true, 
  completedAt: true, 
  reportId: true 
}).refine(
  (data) => {
    if (data.taskType === "recurring") {
      return (
        data.dueDate !== null &&
        data.dueDate !== undefined &&
        data.recurrencePattern && 
        data.recurrencePattern !== "none" &&
        data.recurrenceInterval && 
        data.recurrenceInterval >= 1
      );
    }
    return true;
  },
  {
    message: "Recurring tasks must have a due date, recurrence pattern, and interval >= 1",
  }
).refine(
  (data) => {
    if (data.taskType === "one-time") {
      return data.recurrencePattern === "none" || !data.recurrencePattern;
    }
    return true;
  },
  {
    message: "One-time tasks must not have recurrence settings",
  }
);
export const insertReportSchema = createInsertSchema(reports).omit({ id: true, createdAt: true });
export const insertDocumentSchema = createInsertSchema(documents).omit({ id: true, createdAt: true });
export const insertSparePartSchema = createInsertSchema(spareParts).omit({ id: true, createdAt: true });

export type Profile = typeof profiles.$inferSelect;
export type InsertProfile = z.infer<typeof insertProfileSchema>;

export type Client = typeof clients.$inferSelect;
export type InsertClient = z.infer<typeof insertClientSchema>;

export type Appliance = typeof appliances.$inferSelect;
export type InsertAppliance = z.infer<typeof insertApplianceSchema>;

export type Task = typeof tasks.$inferSelect;
export type InsertTask = z.infer<typeof insertTaskSchema>;

export type Report = typeof reports.$inferSelect;
export type InsertReport = z.infer<typeof insertReportSchema>;

export type Document = typeof documents.$inferSelect;
export type InsertDocument = z.infer<typeof insertDocumentSchema>;

export type SparePart = typeof spareParts.$inferSelect;
export type InsertSparePart = z.infer<typeof insertSparePartSchema>;

export type User = Profile;
