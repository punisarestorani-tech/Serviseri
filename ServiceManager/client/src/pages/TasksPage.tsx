import { useState, useEffect } from "react";
import Header from "@/components/Header";
import BackButton from "@/components/BackButton";
import TaskCard from "@/components/TaskCard";
import AddApplianceDialog from "@/components/AddApplianceDialog";
import AddClientDialog from "@/components/AddClientDialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogDescription } from "@/components/ui/dialog";
import { Search, Repeat, Plus } from "lucide-react";
import { useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { queryClient, apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import { useTranslation } from "@/i18n";
import type { Client, Appliance, User, Task } from "@shared/schema";
import { generateUpcomingDates, getRecurrencePatternLabel, type RecurrencePattern } from "@/lib/recurringUtils";

export default function TasksPage() {
  const t = useTranslation();
  const [, setLocation] = useLocation();
  const [searchQuery, setSearchQuery] = useState("");
  const [taskTypeFilter, setTaskTypeFilter] = useState<string>("all");
  const [isAddTaskOpen, setIsAddTaskOpen] = useState(false);
  const [isAddApplianceOpen, setIsAddApplianceOpen] = useState(false);
  const [isAddClientOpen, setIsAddClientOpen] = useState(false);
  const { toast} = useToast();
  
  const [taskType, setTaskType] = useState<"one-time" | "recurring">("one-time");
  const [clientId, setClientId] = useState("");
  const [applianceId, setApplianceId] = useState("");
  const [userId, setUserId] = useState("");
  const [description, setDescription] = useState("");
  const [priority, setPriority] = useState("normal");
  const [dueDate, setDueDate] = useState("");
  const [recurrencePattern, setRecurrencePattern] = useState<RecurrencePattern>("none");
  const [recurrenceInterval, setRecurrenceInterval] = useState(1);
  
  const { data: clients = [] } = useQuery<Client[]>({
    queryKey: ["/api/clients"],
  });
  
  const { data: appliances = [] } = useQuery<Appliance[]>({
    queryKey: ["/api/appliances"],
  });
  
  const { data: users = [] } = useQuery<User[]>({
    queryKey: ["/api/users"],
  });
  
  const { data: tasks = [], isLoading } = useQuery<Task[]>({
    queryKey: ["/api/tasks"],
    refetchOnMount: true,
  });
  
  const filteredAppliances = clientId 
    ? appliances.filter(a => a.clientId === clientId)
    : [];
  
  const createTaskMutation = useMutation({
    mutationFn: async (taskData: any) => {
      return await apiRequest("POST", "/api/tasks", taskData);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/tasks"] });
      toast({
        description: t.tasks.createSuccess,
      });
      resetForm();
      setIsAddTaskOpen(false);
    },
    onError: (error: any) => {
      toast({
        description: error.message || t.tasks.createError,
        variant: "destructive",
      });
    },
  });
  
  const resetForm = () => {
    setTaskType("one-time");
    setClientId("");
    setApplianceId("");
    setUserId("");
    setDescription("");
    setPriority("normal");
    setDueDate("");
    setRecurrencePattern("none");
    setRecurrenceInterval(1);
  };
  
  const handleAddTask = () => {
    const taskData: any = {
      clientId,
      applianceId: applianceId || null,
      userId: userId || null,
      description,
      priority,
      dueDate: dueDate || null,
      status: "pending",
      taskType,
      recurrencePattern: taskType === "recurring" ? recurrencePattern : "none",
      recurrenceInterval: taskType === "recurring" ? recurrenceInterval : 1,
      isAutoGenerated: 0,
    };
    
    createTaskMutation.mutate(taskData);
  };
  
  const upcomingDates = taskType === "recurring" && dueDate && recurrencePattern !== "none"
    ? generateUpcomingDates(new Date(dueDate), recurrencePattern, recurrenceInterval, 5)
    : [];

  const filteredTasks = tasks.filter((task) => {
    const client = clients.find(c => c.id === task.clientId);
    
    const matchesSearch = !searchQuery || 
      (client?.name && client.name.toLowerCase().includes(searchQuery.toLowerCase()));
    
    const matchesType = taskTypeFilter === "all" || task.taskType === taskTypeFilter;
    
    const isActive = task.status === "pending" || task.status === "in_progress";
    
    return matchesSearch && matchesType && isActive;
  });

  return (
    <div className="min-h-screen bg-background">
      <Header />
      
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-6">
          <BackButton />
        </div>

        <div className="flex items-center justify-between mb-6">
          <h2 className="text-3xl font-bold">{t.tasks.title}</h2>
          <Dialog open={isAddTaskOpen} onOpenChange={setIsAddTaskOpen}>
            <DialogTrigger asChild>
              <Button data-testid="button-add-task">
                {t.tasks.addTask}
              </Button>
            </DialogTrigger>
            <DialogContent className="sm:max-w-2xl max-h-[90vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle>{t.tasks.addTask}</DialogTitle>
                <DialogDescription>
                  {t.tasks.addTaskDescription}
                </DialogDescription>
              </DialogHeader>
              <div className="space-y-4 py-4">
                <div className="space-y-2">
                  <Label>{t.tasks.taskType}</Label>
                  <RadioGroup value={taskType} onValueChange={(value: any) => setTaskType(value)} className="flex gap-4">
                    <div className="flex items-center space-x-2">
                      <RadioGroupItem value="one-time" id="one-time" data-testid="radio-one-time" />
                      <Label htmlFor="one-time" className="font-normal cursor-pointer">{t.tasks.types['one-time']}</Label>
                    </div>
                    <div className="flex items-center space-x-2">
                      <RadioGroupItem value="recurring" id="recurring" data-testid="radio-recurring" />
                      <Label htmlFor="recurring" className="font-normal cursor-pointer flex items-center gap-1">
                        <Repeat className="w-4 h-4" />
                        {t.tasks.types.recurring}
                      </Label>
                    </div>
                  </RadioGroup>
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="task-client">
                      {t.clients.title} <span className="text-destructive">*</span>
                    </Label>
                    <Select value={clientId} onValueChange={(value) => {
                      if (value === "add-new") {
                        setIsAddClientOpen(true);
                      } else {
                        setClientId(value);
                      }
                    }}>
                      <SelectTrigger id="task-client" data-testid="select-task-client">
                        <SelectValue placeholder={t.tasks.selectClient} />
                      </SelectTrigger>
                      <SelectContent>
                        {clients.map(client => (
                          <SelectItem key={client.id} value={client.id}>{client.name}</SelectItem>
                        ))}
                        <SelectItem value="add-new" className="text-primary font-medium">
                          <div className="flex items-center gap-2">
                            <Plus className="w-4 h-4" />
                            {t.tasks.addNewClient}
                          </div>
                        </SelectItem>
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="task-appliance">{t.appliances.title}</Label>
                    <Select value={applianceId} onValueChange={(value) => {
                      if (value === "add-new") {
                        setIsAddApplianceOpen(true);
                      } else {
                        setApplianceId(value);
                      }
                    }} disabled={!clientId}>
                      <SelectTrigger id="task-appliance" data-testid="select-task-appliance">
                        <SelectValue placeholder={clientId ? t.tasks.selectAppliance : t.tasks.selectClientFirst} />
                      </SelectTrigger>
                      <SelectContent>
                        {filteredAppliances.map(appliance => (
                          <SelectItem key={appliance.id} value={appliance.id}>
                            {[appliance.maker, appliance.type, appliance.model].filter(Boolean).join(' - ') || `${t.appliances.title} ${appliance.id.slice(0, 8)}`}
                          </SelectItem>
                        ))}
                        {clientId && (
                          <SelectItem value="add-new" className="text-primary font-medium">
                            <div className="flex items-center gap-2">
                              <Plus className="w-4 h-4" />
                              {t.tasks.addNewAppliance}
                            </div>
                          </SelectItem>
                        )}
                      </SelectContent>
                    </Select>
                  </div>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="task-technician">
                    {t.tasks.assignToTechnician}
                  </Label>
                  <Select value={userId} onValueChange={setUserId}>
                    <SelectTrigger id="task-technician" data-testid="select-task-technician">
                      <SelectValue placeholder={t.tasks.selectTechnician} />
                    </SelectTrigger>
                    <SelectContent>
                      {users.map(user => (
                        <SelectItem key={user.id} value={user.id}>
                          {user.fullName || user.username}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="task-description">
                    {t.tasks.description} <span className="text-destructive">*</span>
                  </Label>
                  <Textarea
                    id="task-description"
                    placeholder={t.tasks.descriptionPlaceholder}
                    value={description}
                    onChange={(e) => setDescription(e.target.value)}
                    data-testid="input-task-description"
                    rows={3}
                  />
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="task-priority">{t.tasks.priority}</Label>
                    <Select value={priority} onValueChange={setPriority}>
                      <SelectTrigger id="task-priority" data-testid="select-task-priority">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="low">{t.tasks.priorities.low}</SelectItem>
                        <SelectItem value="normal">{t.tasks.priorities.normal}</SelectItem>
                        <SelectItem value="high">{t.tasks.priorities.high}</SelectItem>
                        <SelectItem value="urgent">{t.tasks.priorities.urgent}</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="task-due-date">
                      {t.tasks.dueDate} <span className="text-destructive">*</span>
                    </Label>
                    <Input
                      id="task-due-date"
                      type="date"
                      value={dueDate}
                      onChange={(e) => setDueDate(e.target.value)}
                      data-testid="input-task-due-date"
                    />
                  </div>
                </div>

                {taskType === "recurring" && (
                  <div className="space-y-4 p-4 bg-muted rounded-md">
                    <h4 className="font-medium">{t.tasks.recurrenceSettings}</h4>
                    
                    <div className="grid grid-cols-2 gap-4">
                      <div className="space-y-2">
                        <Label htmlFor="recurrence-pattern">{t.tasks.pattern}</Label>
                        <Select value={recurrencePattern} onValueChange={(value: any) => setRecurrencePattern(value)}>
                          <SelectTrigger id="recurrence-pattern" data-testid="select-recurrence-pattern">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="weekly">{t.tasks.recurrencePatterns.weekly}</SelectItem>
                            <SelectItem value="monthly">{t.tasks.recurrencePatterns.monthly}</SelectItem>
                            <SelectItem value="quarterly">{t.tasks.recurrencePatterns.quarterly}</SelectItem>
                            <SelectItem value="semi-annual">{t.tasks.recurrencePatterns['semi-annual']}</SelectItem>
                            <SelectItem value="yearly">{t.tasks.recurrencePatterns.yearly}</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor="recurrence-interval">
                          {t.tasks.every} {
                            recurrencePattern === "weekly" ? t.tasks.intervalUnits.weeks : 
                            recurrencePattern === "monthly" ? t.tasks.intervalUnits.months : 
                            recurrencePattern === "quarterly" ? t.tasks.intervalUnits.quarters :
                            recurrencePattern === "semi-annual" ? t.tasks.intervalUnits.halfYears : 
                            t.tasks.intervalUnits.years
                          }
                        </Label>
                        <Input
                          id="recurrence-interval"
                          type="number"
                          min="1"
                          value={recurrenceInterval}
                          onChange={(e) => setRecurrenceInterval(parseInt(e.target.value) || 1)}
                          data-testid="input-recurrence-interval"
                        />
                      </div>
                    </div>

                    {upcomingDates.length > 0 && (
                      <div className="space-y-2">
                        <Label className="text-sm text-muted-foreground">{t.tasks.nextScheduledDates}</Label>
                        <div className="text-sm space-y-1">
                          {upcomingDates.slice(0, 3).map((date, i) => (
                            <div key={i} className="text-muted-foreground">
                              {date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                <div className="flex gap-3 pt-4">
                  <Button
                    variant="outline"
                    onClick={() => {
                      resetForm();
                      setIsAddTaskOpen(false);
                    }}
                    className="flex-1"
                    data-testid="button-cancel-task"
                  >
                    {t.common.cancel}
                  </Button>
                  <Button
                    onClick={handleAddTask}
                    disabled={!clientId || !description || !dueDate || createTaskMutation.isPending}
                    className="flex-1"
                    data-testid="button-create-task"
                  >
                    {createTaskMutation.isPending ? t.tasks.creating : t.tasks.addTask}
                  </Button>
                </div>
              </div>
            </DialogContent>
          </Dialog>
        </div>

        <div className="space-y-4 mb-6">
          <div className="flex flex-col sm:flex-row gap-4">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                type="search"
                placeholder={t.tasks.searchPlaceholder}
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9"
                data-testid="input-search-tasks"
              />
            </div>
            <Select value={taskTypeFilter} onValueChange={setTaskTypeFilter}>
              <SelectTrigger className="w-full sm:w-48" data-testid="select-type-filter">
                <SelectValue placeholder={t.tasks.filterByType} />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">{t.tasks.allTypes}</SelectItem>
                <SelectItem value="one-time">{t.tasks.types['one-time']}</SelectItem>
                <SelectItem value="recurring">{t.tasks.types.recurring}</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {filteredTasks.map((task: any) => (
            <TaskCard
              key={task.id || task.taskId}
              taskId={task.id || task.taskId}
              description={task.description}
              status={task.status}
              clientName={task.clientName || t.clients.title}
              createdAt={task.dueDate ? new Date(task.dueDate) : task.createdAt}
              taskType={task.taskType || "one-time"}
              recurrencePattern={task.recurrencePattern || "none"}
              recurrenceInterval={task.recurrenceInterval || 1}
              isAutoGenerated={task.isAutoGenerated || false}
              onClick={() => setLocation(`/tasks/${task.id || task.taskId}`)}
            />
          ))}
        </div>

        {filteredTasks.length === 0 && (
          <div className="text-center py-12 text-muted-foreground">
            {t.tasks.noTasks}
          </div>
        )}
      </main>

      <AddApplianceDialog
        open={isAddApplianceOpen}
        onOpenChange={setIsAddApplianceOpen}
        clientId={clientId}
        onSuccess={(newApplianceId) => {
          queryClient.invalidateQueries({ queryKey: ["/api/appliances"] });
          setApplianceId(newApplianceId);
        }}
      />

      <AddClientDialog
        open={isAddClientOpen}
        onOpenChange={setIsAddClientOpen}
        onSuccess={(newClientId) => {
          queryClient.invalidateQueries({ queryKey: ["/api/clients"] });
          setClientId(newClientId);
        }}
      />
    </div>
  );
}
