import { storage } from "./storage";
import type { Task, InsertTask } from "@shared/schema";

export function calculateNextOccurrenceDate(
  baseDate: string,
  pattern: string,
  interval: number = 1
): string | null {
  if (pattern === "none") return null;
  
  const date = new Date(baseDate);
  
  switch (pattern) {
    case "weekly":
      date.setDate(date.getDate() + (7 * interval));
      break;
    case "monthly":
      date.setMonth(date.getMonth() + interval);
      break;
    case "quarterly":
      date.setMonth(date.getMonth() + (3 * interval));
      break;
    case "semi-annual":
      date.setMonth(date.getMonth() + (6 * interval));
      break;
    case "yearly":
      date.setFullYear(date.getFullYear() + interval);
      break;
    default:
      return null;
  }
  
  return date.toISOString().split('T')[0];
}

export async function generateUpcomingRecurringInstances(daysAhead: number = 30): Promise<{
  generated: number;
  tasks: Task[];
}> {
  const allTasks = await storage.getAllTasks();
  const recurringParentTasks = allTasks.filter(
    t => t.taskType === "recurring" && 
        t.recurrencePattern && 
        t.recurrencePattern !== "none" &&
        !t.isAutoGenerated
  );
  
  const newTasks: Task[] = [];
  const today = new Date();
  const horizon = new Date(today);
  horizon.setDate(horizon.getDate() + daysAhead);
  const horizonStr = horizon.toISOString().split('T')[0];
  const todayStr = today.toISOString().split('T')[0];
  
  for (const parentTask of recurringParentTasks) {
    if (!parentTask.dueDate || !parentTask.recurrencePattern) continue;
    
    const existingInstances = allTasks.filter(
      t => t.parentTaskId === parentTask.id && t.status === "pending"
    );
    const existingDueDates = new Set(
      existingInstances.map(t => t.dueDate).filter((d): d is string => d !== null)
    );
    
    let currentDate = parentTask.dueDate < todayStr ? todayStr : parentTask.dueDate;
    while (currentDate && currentDate <= horizonStr) {
      if (!existingDueDates.has(currentDate)) {
        const nextOccurrence = calculateNextOccurrenceDate(
          currentDate,
          parentTask.recurrencePattern,
          parentTask.recurrenceInterval || 1
        );
        
        const newTaskData: InsertTask = {
          clientId: parentTask.clientId,
          applianceId: parentTask.applianceId,
          userId: parentTask.userId,
          description: parentTask.description,
          status: "pending",
          priority: parentTask.priority,
          dueDate: currentDate,
          taskType: "recurring",
          recurrencePattern: parentTask.recurrencePattern,
          recurrenceInterval: parentTask.recurrenceInterval,
          parentTaskId: parentTask.id,
          isAutoGenerated: 1,
          nextOccurrenceDate: nextOccurrence,
        };
        
        const newTask = await storage.createTask(newTaskData);
        newTasks.push(newTask);
        existingDueDates.add(currentDate);
      }
      
      const nextDate = calculateNextOccurrenceDate(
        currentDate,
        parentTask.recurrencePattern,
        parentTask.recurrenceInterval || 1
      );
      
      if (!nextDate || nextDate > horizonStr) break;
      currentDate = nextDate;
    }
  }
  
  return {
    generated: newTasks.length,
    tasks: newTasks,
  };
}

export async function generateRecurringTasks(): Promise<{
  generated: number;
  tasks: Task[];
}> {
  const tasksToRenew = await storage.getRecurringTasksDue();
  const newTasks: Task[] = [];
  
  for (const task of tasksToRenew) {
    if (!task.nextOccurrenceDate || !task.recurrencePattern || task.recurrencePattern === "none") continue;
    
    if (task.isAutoGenerated && task.parentTaskId) {
      continue;
    }
    
    const today = new Date().toISOString().split('T')[0];
    if (task.nextOccurrenceDate > today) continue;
    
    const nextDate = calculateNextOccurrenceDate(
      task.nextOccurrenceDate,
      task.recurrencePattern,
      task.recurrenceInterval || 1
    );
    
    const newTaskData: InsertTask = {
      clientId: task.clientId,
      applianceId: task.applianceId,
      userId: task.userId,
      description: task.description,
      status: "pending",
      priority: task.priority,
      dueDate: task.nextOccurrenceDate,
      taskType: "recurring",
      recurrencePattern: task.recurrencePattern,
      recurrenceInterval: task.recurrenceInterval,
      parentTaskId: task.parentTaskId || task.id,
      isAutoGenerated: 1,
      nextOccurrenceDate: nextDate,
    };
    
    const newTask = await storage.createTask(newTaskData);
    newTasks.push(newTask);
    
    if (!task.parentTaskId) {
      await storage.updateTask(task.id, {
        nextOccurrenceDate: nextDate,
      });
    }
  }
  
  return {
    generated: newTasks.length,
    tasks: newTasks,
  };
}
