import { useState, useEffect } from "react";
import Header from "@/components/Header";
import BackButton from "@/components/BackButton";
import TaskCard from "@/components/TaskCard";
import AddApplianceDialog from "@/components/AddApplianceDialog";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogDescription } from "@/components/ui/dialog";
import { Search, Repeat, Plus } from "lucide-react";
import { useLocation } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { queryClient, apiRequest } from "@/lib/queryClient";
import { useToast } from "@/hooks/use-toast";
import type { Client, Appliance, User, Task } from "@shared/schema";
import { generateUpcomingDates, getRecurrencePatternLabel, type RecurrencePattern } from "@/lib/recurringUtils";
import { startOfWeek, endOfWeek, isWithinInterval, parseISO } from "date-fns";

export default function TasksPage() {
  const [, setLocation] = useLocation();
  const [searchQuery, setSearchQuery] = useState("");
  const [taskTypeFilter, setTaskTypeFilter] = useState<string>("all");
  const [isAddTaskOpen, setIsAddTaskOpen] = useState(false);
  const [isAddApplianceOpen, setIsAddApplianceOpen] = useState(false);
  const { toast} = useToast();
  
  const [taskType, setTaskType] = useState<"one-time" | "recurring">("one-time");
  const [clientId, setClientId] = useState("");
  const [applianceId, setApplianceId] = useState("");
  const [userId, setUserId] = useState("");
  const [description, setDescription] = useState("");
  const [priority, setPriority] = useState("normal");
  const [dueDate, setDueDate] = useState("");
  const [recurrencePattern, setRecurrencePattern] = useState<RecurrencePattern>("none");
  const [recurrenceInterval, setRecurrenceInterval] = useState(1);
  
  const { data: clients = [] } = useQuery<Client[]>({
    queryKey: ["/api/clients"],
  });
  
  const { data: appliances = [] } = useQuery<Appliance[]>({
    queryKey: ["/api/appliances"],
  });
  
  const { data: users = [] } = useQuery<User[]>({
    queryKey: ["/api/users"],
  });
  
  const { data: tasks = [], isLoading } = useQuery<Task[]>({
    queryKey: ["/api/tasks"],
    refetchOnMount: true,
  });
  
  const filteredAppliances = clientId 
    ? appliances.filter(a => a.clientId === clientId)
    : [];
  
  const createTaskMutation = useMutation({
    mutationFn: async (taskData: any) => {
      return await apiRequest("POST", "/api/tasks", taskData);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/tasks"] });
      toast({
        title: "Success",
        description: "Task created successfully",
      });
      resetForm();
      setIsAddTaskOpen(false);
    },
    onError: (error: any) => {
      toast({
        title: "Error",
        description: error.message || "Failed to create task",
        variant: "destructive",
      });
    },
  });
  
  const resetForm = () => {
    setTaskType("one-time");
    setClientId("");
    setApplianceId("");
    setUserId("");
    setDescription("");
    setPriority("normal");
    setDueDate("");
    setRecurrencePattern("none");
    setRecurrenceInterval(1);
  };
  
  const handleAddTask = () => {
    const taskData: any = {
      clientId,
      applianceId: applianceId || null,
      userId: userId || null,
      description,
      priority,
      dueDate: dueDate || null,
      status: "pending",
      taskType,
      recurrencePattern: taskType === "recurring" ? recurrencePattern : "none",
      recurrenceInterval: taskType === "recurring" ? recurrenceInterval : 1,
      nextOccurrenceDate: taskType === "recurring" && dueDate && recurrencePattern !== "none" 
        ? new Date(new Date(dueDate).getTime() + (taskType === "recurring" ? 1 : 0) * 24 * 60 * 60 * 1000).toISOString().split('T')[0]
        : null,
      isAutoGenerated: 0,
    };
    
    createTaskMutation.mutate(taskData);
  };
  
  const upcomingDates = taskType === "recurring" && dueDate && recurrencePattern !== "none"
    ? generateUpcomingDates(new Date(dueDate), recurrencePattern, recurrenceInterval, 5)
    : [];
  
  const isTaskInCurrentWeek = (task: Task) => {
    if (task.taskType !== "recurring" || !task.nextOccurrenceDate) {
      return true;
    }
    
    const now = new Date();
    const weekStart = startOfWeek(now, { weekStartsOn: 1 });
    const weekEnd = endOfWeek(now, { weekStartsOn: 1 });
    
    try {
      const nextDate = typeof task.nextOccurrenceDate === 'string' 
        ? parseISO(task.nextOccurrenceDate)
        : new Date(task.nextOccurrenceDate);
      
      return isWithinInterval(nextDate, { start: weekStart, end: weekEnd });
    } catch (error) {
      return true;
    }
  };

  const filteredTasks = tasks.filter((task) => {
    const client = clients.find(c => c.id === task.clientId);
    
    const matchesSearch = !searchQuery || 
      (client?.name && client.name.toLowerCase().includes(searchQuery.toLowerCase()));
    
    const matchesType = taskTypeFilter === "all" || task.taskType === taskTypeFilter;
    
    const isActive = task.status === "pending" || task.status === "in_progress";
    
    const matchesWeekFilter = task.taskType === "recurring" 
      ? isTaskInCurrentWeek(task) || task.status === "in_progress"
      : true;
    
    return matchesSearch && matchesType && isActive && matchesWeekFilter;
  });

  return (
    <div className="min-h-screen bg-background">
      <Header />
      
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-6">
          <BackButton to="/dashboard" label="Back to Dashboard" />
        </div>

        <div className="flex items-center justify-between mb-6">
          <h2 className="text-3xl font-bold">Tasks</h2>
          <Dialog open={isAddTaskOpen} onOpenChange={setIsAddTaskOpen}>
            <DialogTrigger asChild>
              <Button data-testid="button-add-task">
                Add Task
              </Button>
            </DialogTrigger>
            <DialogContent className="sm:max-w-2xl max-h-[90vh] overflow-y-auto">
              <DialogHeader>
                <DialogTitle>Create New Task</DialogTitle>
                <DialogDescription>
                  Create a one-time repair task or set up recurring inspections
                </DialogDescription>
              </DialogHeader>
              <div className="space-y-4 py-4">
                <div className="space-y-2">
                  <Label>Task Type</Label>
                  <RadioGroup value={taskType} onValueChange={(value: any) => setTaskType(value)} className="flex gap-4">
                    <div className="flex items-center space-x-2">
                      <RadioGroupItem value="one-time" id="one-time" data-testid="radio-one-time" />
                      <Label htmlFor="one-time" className="font-normal cursor-pointer">One-time Repair</Label>
                    </div>
                    <div className="flex items-center space-x-2">
                      <RadioGroupItem value="recurring" id="recurring" data-testid="radio-recurring" />
                      <Label htmlFor="recurring" className="font-normal cursor-pointer flex items-center gap-1">
                        <Repeat className="w-4 h-4" />
                        Recurring Inspection
                      </Label>
                    </div>
                  </RadioGroup>
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="task-client">
                      Client <span className="text-destructive">*</span>
                    </Label>
                    <Select value={clientId} onValueChange={setClientId}>
                      <SelectTrigger id="task-client" data-testid="select-task-client">
                        <SelectValue placeholder="Select client" />
                      </SelectTrigger>
                      <SelectContent>
                        {clients.map(client => (
                          <SelectItem key={client.id} value={client.id}>{client.name}</SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="task-appliance">Appliance</Label>
                    <Select value={applianceId} onValueChange={(value) => {
                      if (value === "add-new") {
                        setIsAddApplianceOpen(true);
                      } else {
                        setApplianceId(value);
                      }
                    }} disabled={!clientId}>
                      <SelectTrigger id="task-appliance" data-testid="select-task-appliance">
                        <SelectValue placeholder={clientId ? "Select appliance" : "Select client first"} />
                      </SelectTrigger>
                      <SelectContent>
                        {filteredAppliances.map(appliance => (
                          <SelectItem key={appliance.id} value={appliance.id}>
                            {[appliance.maker, appliance.type, appliance.model].filter(Boolean).join(' - ') || `Appliance ${appliance.id.slice(0, 8)}`}
                          </SelectItem>
                        ))}
                        {clientId && (
                          <SelectItem value="add-new" className="text-primary font-medium">
                            <div className="flex items-center gap-2">
                              <Plus className="w-4 h-4" />
                              Add new appliance
                            </div>
                          </SelectItem>
                        )}
                      </SelectContent>
                    </Select>
                  </div>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="task-technician">
                    Assign to Technician
                  </Label>
                  <Select value={userId} onValueChange={setUserId}>
                    <SelectTrigger id="task-technician" data-testid="select-task-technician">
                      <SelectValue placeholder="Select technician" />
                    </SelectTrigger>
                    <SelectContent>
                      {users.map(user => (
                        <SelectItem key={user.id} value={user.id}>
                          {user.fullName || user.username}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div className="space-y-2">
                  <Label htmlFor="task-description">
                    Description <span className="text-destructive">*</span>
                  </Label>
                  <Textarea
                    id="task-description"
                    placeholder="Enter task description..."
                    value={description}
                    onChange={(e) => setDescription(e.target.value)}
                    data-testid="input-task-description"
                    rows={3}
                  />
                </div>

                <div className="grid grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="task-priority">Priority</Label>
                    <Select value={priority} onValueChange={setPriority}>
                      <SelectTrigger id="task-priority" data-testid="select-task-priority">
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="low">Low</SelectItem>
                        <SelectItem value="normal">Normal</SelectItem>
                        <SelectItem value="high">High</SelectItem>
                        <SelectItem value="urgent">Urgent</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="task-due-date">
                      Due Date <span className="text-destructive">*</span>
                    </Label>
                    <Input
                      id="task-due-date"
                      type="date"
                      value={dueDate}
                      onChange={(e) => setDueDate(e.target.value)}
                      data-testid="input-task-due-date"
                    />
                  </div>
                </div>

                {taskType === "recurring" && (
                  <div className="space-y-4 p-4 bg-muted rounded-md">
                    <h4 className="font-medium">Recurrence Settings</h4>
                    
                    <div className="grid grid-cols-2 gap-4">
                      <div className="space-y-2">
                        <Label htmlFor="recurrence-pattern">Pattern</Label>
                        <Select value={recurrencePattern} onValueChange={(value: any) => setRecurrencePattern(value)}>
                          <SelectTrigger id="recurrence-pattern" data-testid="select-recurrence-pattern">
                            <SelectValue />
                          </SelectTrigger>
                          <SelectContent>
                            <SelectItem value="weekly">Weekly</SelectItem>
                            <SelectItem value="monthly">Monthly</SelectItem>
                            <SelectItem value="quarterly">Quarterly (3 months)</SelectItem>
                            <SelectItem value="semi-annual">Semi-Annual (6 months)</SelectItem>
                            <SelectItem value="yearly">Yearly</SelectItem>
                          </SelectContent>
                        </Select>
                      </div>

                      <div className="space-y-2">
                        <Label htmlFor="recurrence-interval">
                          Every {recurrencePattern === "weekly" ? "weeks" : 
                                recurrencePattern === "monthly" ? "months" : 
                                recurrencePattern === "quarterly" ? "quarters" :
                                recurrencePattern === "semi-annual" ? "6 months" : "years"}
                        </Label>
                        <Input
                          id="recurrence-interval"
                          type="number"
                          min="1"
                          value={recurrenceInterval}
                          onChange={(e) => setRecurrenceInterval(parseInt(e.target.value) || 1)}
                          data-testid="input-recurrence-interval"
                        />
                      </div>
                    </div>

                    {upcomingDates.length > 0 && (
                      <div className="space-y-2">
                        <Label className="text-sm text-muted-foreground">Next scheduled dates:</Label>
                        <div className="text-sm space-y-1">
                          {upcomingDates.slice(0, 3).map((date, i) => (
                            <div key={i} className="text-muted-foreground">
                              {date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}
                            </div>
                          ))}
                        </div>
                      </div>
                    )}
                  </div>
                )}

                <div className="flex gap-3 pt-4">
                  <Button
                    variant="outline"
                    onClick={() => {
                      resetForm();
                      setIsAddTaskOpen(false);
                    }}
                    className="flex-1"
                    data-testid="button-cancel-task"
                  >
                    Cancel
                  </Button>
                  <Button
                    onClick={handleAddTask}
                    disabled={!clientId || !description || !dueDate || createTaskMutation.isPending}
                    className="flex-1"
                    data-testid="button-create-task"
                  >
                    {createTaskMutation.isPending ? "Creating..." : "Create Task"}
                  </Button>
                </div>
              </div>
            </DialogContent>
          </Dialog>
        </div>

        <div className="space-y-4 mb-6">
          <div className="flex flex-col sm:flex-row gap-4">
            <div className="relative flex-1">
              <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
              <Input
                type="search"
                placeholder="Search by client name..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                className="pl-9"
                data-testid="input-search-tasks"
              />
            </div>
            <Select value={taskTypeFilter} onValueChange={setTaskTypeFilter}>
              <SelectTrigger className="w-full sm:w-48" data-testid="select-type-filter">
                <SelectValue placeholder="Filter by type" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Types</SelectItem>
                <SelectItem value="one-time">One-time</SelectItem>
                <SelectItem value="recurring">Recurring</SelectItem>
              </SelectContent>
            </Select>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {filteredTasks.map((task: any) => (
            <TaskCard
              key={task.id || task.taskId}
              taskId={task.id || task.taskId}
              description={task.description}
              status={task.status}
              clientName={task.clientName || "Client"}
              createdAt={task.dueDate ? new Date(task.dueDate) : task.createdAt}
              taskType={task.taskType || "one-time"}
              recurrencePattern={task.recurrencePattern || "none"}
              recurrenceInterval={task.recurrenceInterval || 1}
              isAutoGenerated={task.isAutoGenerated || false}
              onClick={() => setLocation(`/tasks/${task.id || task.taskId}`)}
            />
          ))}
        </div>

        {filteredTasks.length === 0 && (
          <div className="text-center py-12 text-muted-foreground">
            No tasks found matching your criteria
          </div>
        )}
      </main>

      <AddApplianceDialog
        open={isAddApplianceOpen}
        onOpenChange={setIsAddApplianceOpen}
        clientId={clientId}
        onSuccess={(newApplianceId) => {
          queryClient.invalidateQueries({ queryKey: ["/api/appliances"] });
          setApplianceId(newApplianceId);
        }}
      />
    </div>
  );
}
